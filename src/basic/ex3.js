/* @flow */

//============ Пример параметризованные типы (Generics) ==============


/*
Создана абстракция для типа T. Теперь можно использовать любой тип, какой
нужно, для представления T. Для numberT наше T будет числом. А для arrayT,
оно будет принадлежать типу Array<number>.
*/

type GenericObject<T> = { key: T };

const numberT: GenericObject<number> = { key: 123 };
const stringT: GenericObject<string> = { key: "Preethi" };
const arrayT: GenericObject<Array<number>> = { key: [1, 2, 3] };



//============  Другой пример c моделями ===============================
type Paypal = { id: number, type: 'Paypal' };
type CreditCard = { id: number, type: 'CreditCard' };
type Bank = { id: number, type: 'Bank' };
type PaymentMethod = Paypal | CreditCard | Bank;
type HttpError = { id: string, message: string };

/* Предположим есть такой store и для получения платёжных методов
пользователя нужно сделать запрос к API и, в зависимости от результата
и этапа процесса, приложение может принимать разные состояния.
В реальности, возможно четыре состояния:
  1) Мы не получили платёжные методы.
  2) Мы в процессе получения платёжных методов.
  3) Мы успешно получили платёжные методы.
  4) Мы попытались получить платёжные методы, но возникла ошибка.

*/
type Model = {
  paymentMethods: Array<PaymentMethod> // Массив из объектов модели PaymentMethod
};

/*
Но наш простой тип Model с paymentMethods не покрывает все эти случаи.
Вместо этого он предполагает, что paymentMethods всегда существует.
Перепишем модель чтобы она принимала одно из этих четырёх значений, и только их.
*/

type AppState<E, D>
  = { type: 'NotFetched' }
  | { type: 'Fetching' }
  | { type: 'Failure', error: E }
  | { type: 'Success', paymentMethods: Array<D> };

/*
Мы использовали тип непересекающегося множества для установки AppState в одно
из четырёх состояний, описанных выше. Используем свойство type для определения,
в каком из четырёх состояний находится приложение. Именно это свойство type и
является тем, что создаёт непересекающееся множество. Используя его мы можем
осуществить анализ и определить, когда у нас есть платёжные методы, а когда нет.

Также передаем параметризованный тип E и D в состояние приложения.
 - Тип D будет представлять собой платёжный метод пользователя (PaymentMethod,
определённый выше).
- Тип E будет нашим типом для ошибки
Новый вид модели
*/

type ModelUpdated = AppState<HttpError, PaymentMethod>
